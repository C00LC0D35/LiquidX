package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.Disabler
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.minecraft.item.ItemBucketMilk
import net.minecraft.item.ItemFood
import net.minecraft.item.ItemPotion
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.S07PacketRespawn
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.AxisAlignedBB
import java.util.concurrent.LinkedBlockingQueue

class WatchDog : DisablerMode("WatchDog") {

    private var counter = 0
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0
    private val HypixelDebug = MSTimer()

    //timer
    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayServer>>()
    private val timerCancelDelay = MSTimer()
    private val timerCancelTimer = MSTimer()
    private var canBlink = true

    override fun onWorld(event: WorldEvent) {
        counter = 0
    }

    override fun onEnable() {
        counter = 0
        x = 0.0
        y = 0.0
        z = 0.0
        HypixelDebug.reset()
        timerCancelDelay.reset()
    }

    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        val disabler = LiquidBounce.moduleManager[Disabler::class.java] as Disabler

        // timer test disabler
        if (disabler.timerDisabler.get()) {
            if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                packet is C0APacketAnimation || packet is C0BPacketEntityAction) {
                alerts("Size " + packets.size.toString())
                while (!packets.isEmpty()) {
                    PacketUtils.sendPacketNoEvent(packets.take())
                }
            } else {
                if (canBlink) {
                    packets.add(packet as Packet<INetHandlerPlayServer>)
                    event.cancelEvent()
                }
            }
        }


        // noC03
        if (packet is C03PacketPlayer && !(packet is C03PacketPlayer.C05PacketPlayerLook || packet is C03PacketPlayer.C06PacketPlayerPosLook || packet is C03PacketPlayer.C04PacketPlayerPosition) && disabler.noC03.get()) {
            event.cancelEvent()
            canBlink = false
        }

        // strafe disabler
        if (disabler.strafeDisabler.get() && (mc.thePlayer.ticksExisted < disabler.strafeDisablerPackets.get()) && packet is C03PacketPlayer && (mc.thePlayer.ticksExisted % 15 != 0)) {
            event.cancelEvent()
            canBlink = false
        }


        // anti ban
        if(disabler.lessFlag.get()){
            if (event.packet is C03PacketPlayer.C06PacketPlayerPosLook && mc.thePlayer.onGround && mc.thePlayer.fallDistance>10) {
                if (counter > 0) {
                    if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                        mc.netHandler.networkManager.sendPacket(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                event.packet.x,
                                event.packet.y,
                                event.packet.z,
                                event.packet.onGround
                            )
                        )
                        alerts("Packet C04 Send")
                        event.cancelEvent()
                    }
                }
                counter += 1

                if (event.packet is C03PacketPlayer.C05PacketPlayerLook && mc.thePlayer.isRiding) {
                    mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING))
                    alerts("Packet C0B Send")
                } else if (event.packet is C0CPacketInput && mc.thePlayer.isRiding) {
                    mc.netHandler.networkManager.sendPacket(event.packet)
                    mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))
                    alerts("Packet C0B Send")
                    event.cancelEvent()
                }
            }

            if (event.packet is S08PacketPlayerPosLook) {
                val s08 = event.packet
                x = s08.x
                y = s08.y
                z = s08.z
                alerts("Receive S08")
            }

            if (event.packet is S07PacketRespawn) {
                counter = 0
            }
        }

    }

    override fun onUpdate(event: UpdateEvent) {
        val disabler = LiquidBounce.moduleManager[Disabler::class.java] as Disabler

        //Hypixel Disabler C00
        if (disabler.keepAliveDisabler.get()) {
            if (mc.thePlayer.onGround && isBlockUnder() && mc.thePlayer.fallDistance > 10) {
                mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0, 1000)))
                alerts("Hypixel Disabler C00")
            }
        }

        //Hypixel Disabler C0B & Hypixel Disabler C03
        if (disabler.c0BDisabler.get()) {
            if (mc.thePlayer.ticksExisted % 180 == 90) {
                if (mc.thePlayer.onGround && mc.thePlayer.fallDistance > 10) {
                    mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0, 1000)))
                    alerts("Hypixel Disabler C0B")
                    mc.timer.timerSpeed = 0.8f;
                } else {
                    if (mc.thePlayer.fallDistance < 10) {
                        if (mc.thePlayer.posY == mc.thePlayer.fallDistance.toDouble()) {
                            mc.netHandler.addToSendQueue(C03PacketPlayer(false))
                            if (mc.thePlayer.onGround) mc.timer.timerSpeed = 0.4f;
                            if (mc.thePlayer.fallDistance == 0f) mc.netHandler.addToSendQueue(C03PacketPlayer(true))
                            alerts("Hypixel Disabler C03")
                        }
                    }
                }
            }
        }

        if(mc.thePlayer.posY != 0.0){
            val times=10000 / if(mc.thePlayer.fallDistance.toLong() != 0L) mc.thePlayer.fallDistance.toLong() else 1
            if(HypixelDebug.hasTimePassed(if(times<100) 100 else times) && !mc.thePlayer.onGround && mc.thePlayer.fallDistance != 0f){
                HypixelDebug.reset()
            }else{
                if(mc.thePlayer.fallDistance == 0f) HypixelDebug.reset()
            }
            if (mc.thePlayer.itemInUseDuration >= 1 && isUsingFood()) {
                mc.netHandler.addToSendQueue(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
            }else{
                mc.netHandler.addToSendQueue(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
            }
        }

    }

    fun isUsingFood(): Boolean {
        val usingItem = mc.thePlayer.itemInUse.item
        return if (mc.thePlayer.itemInUse != null) {
            mc.thePlayer.isUsingItem && (usingItem is ItemFood || usingItem is ItemBucketMilk || usingItem is ItemPotion)
        } else false
    }
    fun isBlockUnder(): Boolean {
        if (mc.thePlayer.posY < 0) return false
        var off = 0
        while (off < mc.thePlayer.posY.toInt() + 2) {
            val bb: AxisAlignedBB = mc.thePlayer.getEntityBoundingBox()
                .offset(0.0, -off.toDouble(), 0.0)
            if (mc.theWorld.getCollidingBoundingBoxes(
                    mc.thePlayer,
                    bb
                ).isNotEmpty()
            ) {
                return true
            }
            off += 2
        }
        return false
    }
}
/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other;

import net.ccbluex.liquidbounce.LiquidBounce;
import net.ccbluex.liquidbounce.event.PacketEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode;
import net.ccbluex.liquidbounce.features.module.modules.world.Scaffold;
import net.ccbluex.liquidbounce.utils.PacketUtils;
import net.ccbluex.liquidbounce.utils.misc.RandomUtils;
import net.ccbluex.liquidbounce.utils.timer.TimeHelper;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayServer;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C0BPacketEntityAction;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;

import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.LinkedBlockingQueue;

public final class Intave extends DisablerMode {

    public Intave() {
        super("Intave");
    }

    private final Queue<Packet<?>> linkedQueue = new LinkedBlockingQueue<>();
    private final TimeHelper timer = new TimeHelper();
    private boolean sendAll;


    @Override
    public void onEnable() {
        this.timer.reset();
        this.linkedQueue.clear();
        this.sendAll = true;
    }

    @Override
    public void onUpdate(UpdateEvent event) {
        if (mc.thePlayer == null) {
            return;
        }

        if (mc.thePlayer.ticksExisted < 3) {
            this.linkedQueue.clear();
            this.timer.reset();
        }

        if (mc.thePlayer != null && mc.thePlayer.ticksExisted < 150) {
            this.sendAll = true;
        }

        if (this.sendAll && this.timer.reach(1000L * RandomUtils.nextInt(5, 20))) {
            boolean maxed = this.linkedQueue.size() >= 500;

            if (!maxed && !this.linkedQueue.isEmpty()) {
                Packet<?> packet = this.linkedQueue.poll();

                PacketUtils.sendPacketNoEvent((Packet<INetHandlerPlayServer>) packet);
            }

            this.timer.reset();
        }

    }

    @Override
    public void onPacket(PacketEvent event) {
        if (event.getPacket() instanceof C00PacketKeepAlive) {
            event.cancelEvent();

            this.linkedQueue.add(event.getPacket());
        }

        if (event.getPacket() instanceof C0FPacketConfirmTransaction) {
            C0FPacketConfirmTransaction packet = (C0FPacketConfirmTransaction) event.getPacket();

            if (packet.getUid() > 0 && packet.getUid() < 75) {
                return;
            }

            this.linkedQueue.add(event.getPacket());
            event.cancelEvent();
        }

        if (event.getPacket() instanceof C0FPacketConfirmTransaction && mc.thePlayer.ticksExisted % 2 == 0 && !Objects.requireNonNull(LiquidBounce.moduleManager.getModule(Scaffold.class)).isToggled()) {
            event.cancelEvent();
        }
        if (Objects.requireNonNull(LiquidBounce.moduleManager.getModule(Scaffold.class)).isToggled() && event.getPacket() instanceof C0BPacketEntityAction) {
            event.cancelEvent();
        }

        if (mc.thePlayer != null && mc.thePlayer.ticksExisted < 8) {
            this.linkedQueue.clear();
            this.timer.reset();
        }
    }

}
